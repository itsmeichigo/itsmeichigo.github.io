<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Huong Do</title><link>/</link><description>Recent content on Huong Do</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Huong Do</copyright><lastBuildDate>Tue, 14 Jun 2022 10:00:02 +0701</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>Async Sequence instead of Combine?</title><link>/posts/async-sequence-combine/</link><pubDate>Tue, 14 Jun 2022 10:00:02 +0701</pubDate><guid>/posts/async-sequence-combine/</guid><description>Ever since WWDC 2021, Iâ€™ve seen folks getting excited about the introduction of Swift concurrency, a.k.a async/await. Itâ€™s very common to come across comments that async/await will soon replace Combine, due to its potential and friendliness.
TL;DR: The motivation of this post is to discover the power of AsyncSequence when used with Async Algorithms, to see if we can use it in place of Combine. To be more specific, Iâ€™m curious to see if we can use it with SwiftUI to handle form validation â€“ one of my favorite applications of Combine when working with SwiftUI.</description></item><item><title>Working with observable objects in SwiftUI</title><link>/posts/swiftui-observable-objects/</link><pubDate>Sat, 11 Sep 2021 10:00:02 +0701</pubDate><guid>/posts/swiftui-observable-objects/</guid><description>Earlier this week I learned about @StateObject initializer when reviewing a pull request. The idea was to create a view model for a SwiftUI view using some injected parameter and keep the view model as a @StateObject so that the its state is persisted when the view is redrawn. The view creates the @StateObject like so:
class ItemViewModel: ObservableObject { @Published var itemName: String init(item: Item) { self.itemName = item.name } } struct ItemView: View { @StateObject private var viewModel: ItemViewModel init(item: Item) { _viewModel = StateObject(wrappedValue: ItemViewModel(item: item)) } var body: some View { TextField(&amp;#34;Item Name&amp;#34;, text: viewModel.</description></item><item><title>Breaking down large pull requests</title><link>/posts/breaking-down-pull-requests/</link><pubDate>Tue, 13 Jul 2021 17:02:02 +0700</pubDate><guid>/posts/breaking-down-pull-requests/</guid><description>This post was originally posted in WooCommerce Mobile Project P2 page. I figure this can be useful for other fellow developers as well so this is my public version of the post.
Usually we have several teams working on different features, and we break down tasks into bite-size ones â€“ so large PRs arenâ€™t really a problem. However, for folks working alone on a backlog story, or joining the team for General Maintenance Rotation, and especially Trialmatticians â€“ itâ€™s common to face the issue of handling a big task and having to break them down into smaller parts.</description></item><item><title>Combine from RxSwift - Highlights for smooth adaption</title><link>/posts/combine-from-rxswift/</link><pubDate>Wed, 16 Dec 2020 21:23:02 +0700</pubDate><guid>/posts/combine-from-rxswift/</guid><description>RxSwift has been around since 2015 and widely known among Apple developer community as an efficient open-sourced FRP library. In WWDC 2019 Apple introduced their very own FRP framework, making it possible to utilize the paradigm natively with declarative Swift API. The two frameworks share quite a few similarities in terms of principles and usage, so it can be not too daunting to get your feet wet with Combine if you have already been using RxSwift in your projects.</description></item><item><title>Learning SwiftUI by Building a Slack-like Emoji Picker</title><link>/posts/swiftui-happy-panel/</link><pubDate>Wed, 02 Sep 2020 21:23:02 +0701</pubDate><guid>/posts/swiftui-happy-panel/</guid><description>I started learning SwiftUI around August 2020 first with Apple&amp;rsquo;s SwiftUI Tutorials. The tutorials were really fun and got me excited with using SwiftUI. I then continued with Paul Hudson&amp;rsquo;s series 100 Days of SwiftUI. Around the end of series, I could not hesitate any longer so I started a new Xcode project and build one of the things I like most about Slack app: the emoji picker!
The point of the Happy Panel project was to learn SwiftUI and make use of its declarative syntax to build a complicated control with gestures and animations in a few lines of code.</description></item><item><title>About</title><link>/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/about/</guid><description>Hi there ðŸ‘‹
My name is Huong Do, a.k.a ichigo (yes, lowercased) for simpler pronunciation. I work fulltime as an iOS developer and spend my free time drinking tea, reading fictions and making random things like apps.</description></item></channel></rss>