<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Swift on Huong Do</title><link>/tags/swift/</link><description>Recent content in Swift on Huong Do</description><generator>Hugo</generator><language>en</language><copyright>Huong Do</copyright><lastBuildDate>Mon, 12 Feb 2024 17:00:00 +0701</lastBuildDate><atom:link href="/tags/swift/index.xml" rel="self" type="application/rss+xml"/><item><title>Building a CLI tool with SwiftPM for Mac app distribution</title><link>/posts/dmg-notary/</link><pubDate>Mon, 12 Feb 2024 17:00:00 +0701</pubDate><guid>/posts/dmg-notary/</guid><description>&lt;p&gt;Last week, I wanted to add an update to one of my mac apps &lt;a href="https://itsmeichigo.io/peachy"&gt;Peachy&lt;/a&gt; after a long time. I realized that the &lt;code&gt;atool&lt;/code&gt; used for notarizing mac apps has long been discontinued and it was time to switch to &lt;a href="https://developer.apple.com/documentation/security/notarizing_macos_software_before_distribution"&gt;&lt;code&gt;notarytool&lt;/code&gt;&lt;/a&gt;. It took me a while to read through Apple documentations and WWDC videos again to finally be able to distribute a working DMG for the new version.&lt;/p&gt;
&lt;p&gt;I had some free time due to the Lunar new year holiday, so this was an opportunity to learn something new. It&amp;rsquo;s time to automate the distribution process for my mac apps, and a CLI tool is a perfect solution for this.&lt;/p&gt;</description></item><item><title>An Adventure with Swift Charts</title><link>/posts/swift-charts/</link><pubDate>Mon, 04 Jul 2022 12:23:02 +0700</pubDate><guid>/posts/swift-charts/</guid><description>&lt;p&gt;&lt;em&gt;This post was original posted on &lt;a href="https://mobile.blog/2022/07/04/an-adventure-with-swift-charts/"&gt;mobile.blog&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;As you all may already know, one of the cool new things introduced in WWDC 2022 was &lt;a href="https://developer.apple.com/documentation/Charts"&gt;Swift Charts&lt;/a&gt;, a framework to create charts with SwiftUI. To learn more about the Swift Charts&amp;rsquo; potential, let&amp;rsquo;s go on a thrilling adventure to replace the chart in &lt;a href="https://apps.apple.com/us/app/woocommerce/id1389130815"&gt;WooCommerce iOS&lt;/a&gt; with this ✨✨ shiny new framework ✨✨.&lt;/p&gt;
&lt;p&gt;To get started, here&amp;rsquo;s what the chart currently looks like in WooCommerce iOS. We&amp;rsquo;d want to build something similar using Swift Charts:&lt;/p&gt;</description></item><item><title>Async Sequence instead of Combine?</title><link>/posts/async-sequence-combine/</link><pubDate>Tue, 14 Jun 2022 10:00:02 +0701</pubDate><guid>/posts/async-sequence-combine/</guid><description>&lt;p&gt;Ever since WWDC 2021, I’ve seen folks getting excited about the introduction of Swift concurrency, a.k.a async/await. It’s very common to come across comments that async/await will soon replace Combine, due to its potential and friendliness.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TL;DR&lt;/strong&gt;: The motivation of this post is to discover the power of &lt;a href="https://href.li/?https://developer.apple.com/documentation/Swift/AsyncSequence"&gt;AsyncSequence&lt;/a&gt; when used with &lt;a href="https://href.li/?https://github.com/apple/swift-async-algorithms"&gt;Async Algorithms&lt;/a&gt;, to see if we can use it in place of Combine. To be more specific, I’m curious to see if we can use it with SwiftUI to handle form validation – one of my favorite applications of Combine when working with SwiftUI.&lt;/p&gt;</description></item><item><title>Working with observable objects in SwiftUI</title><link>/posts/swiftui-observable-objects/</link><pubDate>Sat, 11 Sep 2021 10:00:02 +0701</pubDate><guid>/posts/swiftui-observable-objects/</guid><description>&lt;p&gt;Earlier this week I learned about &lt;code&gt;@StateObject&lt;/code&gt; &lt;a href="https://developer.apple.com/documentation/swiftui/stateobject/init%28wrappedvalue:%29"&gt;initializer&lt;/a&gt; when reviewing a pull request. The idea was to create a view model for a SwiftUI view using some injected parameter and keep the view model as a &lt;code&gt;@StateObject&lt;/code&gt; so that the its state is persisted when the view is redrawn. The view creates the &lt;code&gt;@StateObject&lt;/code&gt; like so:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-swift" data-lang="swift"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;class&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;ItemViewModel&lt;/span&gt;: ObservableObject {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; @Published &lt;span style="color:#66d9ef"&gt;var&lt;/span&gt; itemName: String
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;init&lt;/span&gt;(item: Item) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;self&lt;/span&gt;.itemName = item.name
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;struct&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;ItemView&lt;/span&gt;: View {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; @StateObject &lt;span style="color:#66d9ef"&gt;private&lt;/span&gt; &lt;span style="color:#66d9ef"&gt;var&lt;/span&gt; viewModel: ItemViewModel
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;init&lt;/span&gt;(item: Item) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; _viewModel = StateObject(wrappedValue: ItemViewModel(item: item))
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#66d9ef"&gt;var&lt;/span&gt; body: some View {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; TextField(&lt;span style="color:#e6db74"&gt;&amp;#34;Item Name&amp;#34;&lt;/span&gt;, text: viewModel.&lt;span style="color:#960050;background-color:#1e0010"&gt;$&lt;/span&gt;itemName)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The problem with this initializer is that it&amp;rsquo;s not meant to be used directly. As Apple documentation says it:&lt;/p&gt;</description></item><item><title>Combine from RxSwift - Highlights for smooth adaption</title><link>/posts/combine-from-rxswift/</link><pubDate>Wed, 16 Dec 2020 21:23:02 +0700</pubDate><guid>/posts/combine-from-rxswift/</guid><description>&lt;p&gt;RxSwift has been around since 2015 and widely known among Apple developer community as an efficient open-sourced FRP library. In WWDC 2019 Apple introduced their very own FRP framework, making it possible to utilize the paradigm natively with declarative Swift API. The two frameworks share quite a few similarities in terms of principles and usage, so it can be not too daunting to get your feet wet with Combine if you have already been using RxSwift in your projects.&lt;/p&gt;</description></item><item><title>Learning SwiftUI by Building a Slack-like Emoji Picker</title><link>/posts/swiftui-happy-panel/</link><pubDate>Wed, 02 Sep 2020 21:23:02 +0701</pubDate><guid>/posts/swiftui-happy-panel/</guid><description>&lt;p&gt;I started learning SwiftUI around August 2020 first with &lt;a href="https://developer.apple.com/tutorials/SwiftUI"&gt;Apple&amp;rsquo;s SwiftUI Tutorials&lt;/a&gt;. The tutorials were really fun and got me excited with using SwiftUI. I then continued with Paul Hudson&amp;rsquo;s series &lt;a href="https://www.hackingwithswift.com/100/swiftui"&gt;100 Days of SwiftUI&lt;/a&gt;. Around the end of series, I could not hesitate any longer so I started a new Xcode project and build one of the things I like most about Slack app: the emoji picker!&lt;/p&gt;
&lt;p&gt;&lt;img src="https://github.com/itsmeichigo/HappyPanel/blob/master/screenshot.png?raw=true" alt="Happy Panel"&gt;&lt;/p&gt;
&lt;p&gt;The point of the &lt;a href="https://github.com/itsmeichigo/HappyPanel"&gt;Happy Panel project&lt;/a&gt; was to learn SwiftUI and make use of its declarative syntax to build a complicated control with gestures and animations in a few lines of code. Because the biggest motivation for me to learn something new is to be able to make something beautiful and performant.&lt;/p&gt;</description></item></channel></rss>