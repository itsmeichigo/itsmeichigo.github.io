<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>swift on Huong Do</title><link>/tags/swift/</link><description>Recent content in swift on Huong Do</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Huong Do</copyright><lastBuildDate>Mon, 04 Jul 2022 12:23:02 +0700</lastBuildDate><atom:link href="/tags/swift/index.xml" rel="self" type="application/rss+xml"/><item><title>An Adventure with Swift Charts</title><link>/posts/swift-charts/</link><pubDate>Mon, 04 Jul 2022 12:23:02 +0700</pubDate><guid>/posts/swift-charts/</guid><description>This post was original posted on mobile.blog.
As you all may already know, one of the cool new things introduced in WWDC 2022 was Swift Charts, a framework to create charts with SwiftUI. To learn more about the Swift Charts&amp;rsquo; potential, let&amp;rsquo;s go on a thrilling adventure to replace the chart in WooCommerce iOS with this ✨✨ shiny new framework ✨✨.
To get started, here&amp;rsquo;s what the chart currently looks like in WooCommerce iOS.</description></item><item><title>Async Sequence instead of Combine?</title><link>/posts/async-sequence-combine/</link><pubDate>Tue, 14 Jun 2022 10:00:02 +0701</pubDate><guid>/posts/async-sequence-combine/</guid><description>Ever since WWDC 2021, I’ve seen folks getting excited about the introduction of Swift concurrency, a.k.a async/await. It’s very common to come across comments that async/await will soon replace Combine, due to its potential and friendliness.
TL;DR: The motivation of this post is to discover the power of AsyncSequence when used with Async Algorithms, to see if we can use it in place of Combine. To be more specific, I’m curious to see if we can use it with SwiftUI to handle form validation – one of my favorite applications of Combine when working with SwiftUI.</description></item><item><title>Working with observable objects in SwiftUI</title><link>/posts/swiftui-observable-objects/</link><pubDate>Sat, 11 Sep 2021 10:00:02 +0701</pubDate><guid>/posts/swiftui-observable-objects/</guid><description>Earlier this week I learned about @StateObject initializer when reviewing a pull request. The idea was to create a view model for a SwiftUI view using some injected parameter and keep the view model as a @StateObject so that the its state is persisted when the view is redrawn. The view creates the @StateObject like so:
class ItemViewModel: ObservableObject { @Published var itemName: String init(item: Item) { self.itemName = item.name } } struct ItemView: View { @StateObject private var viewModel: ItemViewModel init(item: Item) { _viewModel = StateObject(wrappedValue: ItemViewModel(item: item)) } var body: some View { TextField(&amp;#34;Item Name&amp;#34;, text: viewModel.</description></item><item><title>Combine from RxSwift - Highlights for smooth adaption</title><link>/posts/combine-from-rxswift/</link><pubDate>Wed, 16 Dec 2020 21:23:02 +0700</pubDate><guid>/posts/combine-from-rxswift/</guid><description>RxSwift has been around since 2015 and widely known among Apple developer community as an efficient open-sourced FRP library. In WWDC 2019 Apple introduced their very own FRP framework, making it possible to utilize the paradigm natively with declarative Swift API. The two frameworks share quite a few similarities in terms of principles and usage, so it can be not too daunting to get your feet wet with Combine if you have already been using RxSwift in your projects.</description></item><item><title>Learning SwiftUI by Building a Slack-like Emoji Picker</title><link>/posts/swiftui-happy-panel/</link><pubDate>Wed, 02 Sep 2020 21:23:02 +0701</pubDate><guid>/posts/swiftui-happy-panel/</guid><description>I started learning SwiftUI around August 2020 first with Apple&amp;rsquo;s SwiftUI Tutorials. The tutorials were really fun and got me excited with using SwiftUI. I then continued with Paul Hudson&amp;rsquo;s series 100 Days of SwiftUI. Around the end of series, I could not hesitate any longer so I started a new Xcode project and build one of the things I like most about Slack app: the emoji picker!
The point of the Happy Panel project was to learn SwiftUI and make use of its declarative syntax to build a complicated control with gestures and animations in a few lines of code.</description></item></channel></rss>