<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>swiftui on Huong Do</title><link>/tags/swiftui/</link><description>Recent content in swiftui on Huong Do</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Huong Do</copyright><lastBuildDate>Mon, 04 Jul 2022 12:23:02 +0700</lastBuildDate><atom:link href="/tags/swiftui/index.xml" rel="self" type="application/rss+xml"/><item><title>An Adventure with Swift Charts</title><link>/posts/swift-charts/</link><pubDate>Mon, 04 Jul 2022 12:23:02 +0700</pubDate><guid>/posts/swift-charts/</guid><description>This post was original posted on mobile.blog.
As you all may already know, one of the cool new things introduced in WWDC 2022 was Swift Charts, a framework to create charts with SwiftUI. To learn more about the Swift Charts&amp;rsquo; potential, let&amp;rsquo;s go on a thrilling adventure to replace the chart in WooCommerce iOS with this ‚ú®‚ú® shiny new framework ‚ú®‚ú®.
To get started, here&amp;rsquo;s what the chart currently looks like in WooCommerce iOS.</description></item><item><title>Working with observable objects in SwiftUI</title><link>/posts/swiftui-observable-objects/</link><pubDate>Sat, 11 Sep 2021 10:00:02 +0701</pubDate><guid>/posts/swiftui-observable-objects/</guid><description>Earlier this week I learned about @StateObject initializer when reviewing a pull request. The idea was to create a view model for a SwiftUI view using some injected parameter and keep the view model as a @StateObject so that the its state is persisted when the view is redrawn. The view creates the @StateObject like so:
class ItemViewModel: ObservableObject { @Published var itemName: String init(item: Item) { self.itemName = item.name } } struct ItemView: View { @StateObject private var viewModel: ItemViewModel init(item: Item) { _viewModel = StateObject(wrappedValue: ItemViewModel(item: item)) } var body: some View { TextField(&amp;#34;Item Name&amp;#34;, text: viewModel.</description></item><item><title>Releasing Fretboard üé∏</title><link>/posts/fretboard/</link><pubDate>Sat, 30 Jan 2021 10:00:02 +0701</pubDate><guid>/posts/fretboard/</guid><description>Fretboard is a weekend project to display guitar and ukulele chords using SwiftUI.
Features:
üéµ Chord positions üåó Light / Dark modes üé∏ Guitar &amp;amp; ukulele chords with basic tunings ‚è≥ More to come. Installation Swift Package Manager Add https://github.com/itsmeichigo/Fretboard.git as the source and you&amp;rsquo;re good to go.
Manual install Copy contents from Sources folder to your project.
Usage Get your desired instruments:
let guitar = Instrument.guitar let ukulele = Instrument.</description></item><item><title>Learning SwiftUI by Building a Slack-like Emoji Picker</title><link>/posts/swiftui-happy-panel/</link><pubDate>Wed, 02 Sep 2020 21:23:02 +0701</pubDate><guid>/posts/swiftui-happy-panel/</guid><description>I started learning SwiftUI around August 2020 first with Apple&amp;rsquo;s SwiftUI Tutorials. The tutorials were really fun and got me excited with using SwiftUI. I then continued with Paul Hudson&amp;rsquo;s series 100 Days of SwiftUI. Around the end of series, I could not hesitate any longer so I started a new Xcode project and build one of the things I like most about Slack app: the emoji picker!
The point of the Happy Panel project was to learn SwiftUI and make use of its declarative syntax to build a complicated control with gestures and animations in a few lines of code.</description></item></channel></rss>