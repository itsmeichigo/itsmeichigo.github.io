<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="ie=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=author content>
<meta name=description content="RxSwift has been around since 2015 and widely known among Apple developer community as an efficient open-sourced FRP library. In WWDC 2019 Apple introduced their very own FRP framework, making it possible to utilize the paradigm natively with declarative Swift API. The two frameworks share quite a few similarities in terms of principles and usage, so it can be not too daunting to get your feet wet with Combine if you have already been using RxSwift in your projects.">
<meta name=keywords content="swift,learning,tech,apps,swift,rxswift,combine">
<meta name=robots content="noodp">
<meta name=theme-color content>
<link rel=canonical href=/posts/combine-from-rxswift/>
<title>
Combine from RxSwift - Highlights for smooth adaption :: Huong Do üçì
</title>
<link href=https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.5.0/css/flag-icon.min.css rel=stylesheet type=text/css>
<link rel=stylesheet href=/main.1ba7d26d0c4324706d3a8a940ddf4a745defa78b99020c5643d5b32b6074a5ba.css>
<meta itemprop=name content="Combine from RxSwift - Highlights for smooth adaption">
<meta itemprop=description content="RxSwift has been around since 2015 and widely known among Apple developer community as an efficient open-sourced FRP library. In WWDC 2019 Apple introduced their very own FRP framework, making it possible to utilize the paradigm natively with declarative Swift API. The two frameworks share quite a few similarities in terms of principles and usage, so it can be not too daunting to get your feet wet with Combine if you have already been using RxSwift in your projects."><meta itemprop=datePublished content="2020-12-16T21:23:02+07:00">
<meta itemprop=dateModified content="2020-12-16T21:23:02+07:00">
<meta itemprop=wordCount content="2517"><meta itemprop=image content="/combine-carbon.png">
<meta itemprop=keywords content="swift,rxswift,combine,">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="/combine-carbon.png">
<meta name=twitter:title content="Combine from RxSwift - Highlights for smooth adaption">
<meta name=twitter:description content="RxSwift has been around since 2015 and widely known among Apple developer community as an efficient open-sourced FRP library. In WWDC 2019 Apple introduced their very own FRP framework, making it possible to utilize the paradigm natively with declarative Swift API. The two frameworks share quite a few similarities in terms of principles and usage, so it can be not too daunting to get your feet wet with Combine if you have already been using RxSwift in your projects.">
<meta property="og:title" content="Combine from RxSwift - Highlights for smooth adaption">
<meta property="og:description" content="RxSwift has been around since 2015 and widely known among Apple developer community as an efficient open-sourced FRP library. In WWDC 2019 Apple introduced their very own FRP framework, making it possible to utilize the paradigm natively with declarative Swift API. The two frameworks share quite a few similarities in terms of principles and usage, so it can be not too daunting to get your feet wet with Combine if you have already been using RxSwift in your projects.">
<meta property="og:type" content="article">
<meta property="og:url" content="/posts/combine-from-rxswift/"><meta property="og:image" content="/combine-carbon.png"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2020-12-16T21:23:02+07:00">
<meta property="article:modified_time" content="2020-12-16T21:23:02+07:00"><meta property="og:site_name" content="Huong Do üçì">
<meta property="article:published_time" content="2020-12-16 21:23:02 +0700 +0700">
</head>
<body class=dark-theme>
<div class=container>
<header class=header>
<span class=header__inner>
<a href=/ style=text-decoration:none>
<div class=logo>
<span class=logo__mark>></span>
<span class=logo__text>cd home/</span>
<span class=logo__cursor>
</span>
</div>
</a>
<span class=header__right>
<nav class=menu>
<ul class=menu__inner><li><a href=/about>about</a></li><li><a href=/posts>posts</a></li>
</ul>
</nav>
<span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>
</span>
<span class="theme-toggle unselectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg>
</span>
</span>
</span>
</header>
<div class=content>
<main class=post>
<div class=post-info>
<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
12 minutes
</p>
</div>
<article>
<h1 class=post-title>
<a href=/posts/combine-from-rxswift/>Combine from RxSwift - Highlights for smooth adaption</a>
</h1>
<div class=post-content>
<p>RxSwift has been around since 2015 and widely known among Apple developer community as an efficient open-sourced FRP library. In WWDC 2019 Apple introduced their very own FRP framework, making it possible to utilize the paradigm natively with declarative Swift API. The two frameworks share quite a few similarities in terms of principles and usage, so it can be not too daunting to get your feet wet with Combine if you have already been using RxSwift in your projects.</p>
<p>If you search around the topic, it‚Äôs easy to find a <a href=https://medium.com/gett-engineering/rxswift-to-apples-combine-cheat-sheet-e9ce32b14c5b>cheatsheet</a> for migrating from RxSwift to Combine summed up by <a href=https://twitter.com/freak4pc>Shai Mishali</a> which is helpful to have a good overview comparision between the two frameworks. In this article I would like to highlight some interesting points about Combine from the viewpoint of a developer who has been working with RxSwift for more than two years.</p>
<h2 id=publishers--subscribers>Publishers & Subscribers</h2>
<p>These two are the equivalents of Observables and Observers in RxSwift. Together they make up the core components of Combine. As Apple put it:</p>
<blockquote>
<p>Combine declares publishers to expose values that can change over time, and subscribers to receive those values from the publishers.</p>
</blockquote>
<p>The great thing about using the native FRP framework is that it has been integrated into other Apple‚Äôs frameworks, making the migration process easier. Foundation framework has supported the use of Combine in some of its APIs, like <code>URLSession</code> in the following example:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RepoListViewModel</span> {
    <span style=color:#66d9ef>var</span> cancellable: AnyCancellable?
    
    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>fetchRepos</span>() {
        <span style=color:#66d9ef>let</span> url = URL(string: <span style=color:#e6db74>&#34;https://api.github.com/users/itsmeichigo/repos&#34;</span>)<span style=color:#f92672>!</span>
        cancellable = URLSession.shared.dataTaskPublisher(<span style=color:#66d9ef>for</span>: url)
            .sink (receiveCompletion: { completion <span style=color:#66d9ef>in</span>
                <span style=color:#66d9ef>switch</span> completion {
                <span style=color:#66d9ef>case</span> .finished:
                    print(<span style=color:#e6db74>&#34;Get repos finished&#34;</span>)
                <span style=color:#66d9ef>case</span> <span style=color:#66d9ef>let</span> .failure(error):
                    print(<span style=color:#e6db74>&#34;Get repos failed: </span><span style=color:#e6db74>\(</span>error<span style=color:#e6db74>)</span><span style=color:#e6db74>&#34;</span>)
                }
            }, receiveValue: { (data, response) <span style=color:#66d9ef>in</span>
                print(<span style=color:#e6db74>&#34;Got repos data: </span><span style=color:#e6db74>\(</span>data<span style=color:#e6db74>)</span><span style=color:#e6db74>&#34;</span>)
            })
    }
}
</code></pre></div><p>In this example, <code>URLSession</code> uses <code>Publisher</code> as a wrapper to emit signals to its subscribers on receipt of response from the URL request.¬†<code>.sink</code> is a method to create a subscription by connecting a subscriber of type <code>Sink</code> to a publisher. This method accepts one closure for execution when receiving new elements and another for handling completion. This is similar to RxSwift Observable&rsquo;s <code>subscribe</code> method which lets us handle when a stream emits new event, completes or errors out.</p>
<p>Subscriptions in Combine can also be handled by assigning values to class properties that are marked with <code>@Published</code> - which is quite similar to <code>bind(to:)</code> method in RxSwift Observable:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Repo</span>: Decodable {
    <span style=color:#66d9ef>let</span> name: String
    <span style=color:#66d9ef>let</span> description: String?
    <span style=color:#66d9ef>let</span> language: String?
}

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RepoDetailViewModel</span> {
    @Published <span style=color:#66d9ef>var</span> repoDetail: Repo?
        
    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>fetchRepoDetail</span>() {
        <span style=color:#66d9ef>let</span> url = URL(string: <span style=color:#e6db74>&#34;https://api.github.com/repos/itsmeichigo/Playgrounds&#34;</span>)<span style=color:#f92672>!</span>
        URLSession.shared.dataTaskPublisher(<span style=color:#66d9ef>for</span>: url)
            .tryMap(<span style=color:#960050;background-color:#1e0010>\</span>.data)
            .decode(type: Repo?.<span style=color:#66d9ef>self</span>, decoder: JSONDecoder())
            .replaceError(with: <span style=color:#66d9ef>nil</span>)
            .assign(to: <span style=color:#f92672>&amp;</span><span style=color:#960050;background-color:#1e0010>$</span>repoDetail)
    }
}
</code></pre></div><p>Note: In case you‚Äôre wondering, since parameter sent to this <code>assign</code> method is <code>inout</code>, an <code>&</code> operator is required to precede <code>$repoDetail</code>. The <code>$</code> operator is used for accessing the wrapped property itself.</p>
<p>The preceding example uses the property wrapper <code>@Published</code> to create a publisher that outputs values of type <code>Repo?</code> and has failure type <code>Never</code> (meaning the stream never fails - more on that later). The <code>repoDetail</code> therefore can be observed for changes by another subscriber:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RepoDetailViewController</span>: UIViewController {
    <span style=color:#66d9ef>@IBOutlet</span> <span style=color:#66d9ef>var</span> titleLabel: UILabel!
    <span style=color:#66d9ef>var</span> viewModel: RepoDetailViewModel!
    <span style=color:#66d9ef>var</span> cancellable: AnyCancellable?
    
    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>viewDidLoad</span>() {
        <span style=color:#66d9ef>super</span>.viewDidLoad()
        cancellable = viewModel.<span style=color:#960050;background-color:#1e0010>$</span>repoDetail
            .map { $0?.name }
            .assign(to: <span style=color:#960050;background-color:#1e0010>\</span>.text, on: titleLabel)

		viewModel.fetchRepoDetails()
    }
}
</code></pre></div><p>As can be noticed from the subscription of <code>repoDetail</code>, another method <code>assign(to:on:)</code> is used to assign the mapped <code>name</code> value to <code>titleLabel</code>&rsquo;s displayed text using KVO. This method keeps strong reference to the object passed to <code>on:</code>, so it should be used with caution to avoid retain cycle if you happen to send <code>self</code>. Although a quick workaround would be to send <code>weak self</code> instead, if you find yourself in such situation, it&rsquo;s time to use an <code>@Published</code> property instead (unfortunately <code>assign(to:)</code> is only available since iOS 14).</p>
<h2 id=subjects>Subjects</h2>
<p>Similar to RxSwift, Combine has the same concept of Subjects‚Ää‚Äî‚Ääthe types of publishers that allow injection of values to be published. Subjects are useful for quickly creating custom publishers and migrating from imperative programming to FRP. There are two built-in subjects:</p>
<ul>
<li><code>PassthroughSubject</code>: equivalent to PublishSubject in RxSwift. This subject broadcasts elements to downstream subscribers, suitable for stateless streams of events. This is usually used for observing user interactions (button taps, toggle switches etc.) or sending notifications.</li>
<li><code>CurrentValueSubject</code>: equivalent to BehaviorSubject in RxSwift. This subject wraps a stream of output of value type and exposes the most recently published element via <code>value</code> variable. New values can be injected to the stream by updating the <code>value</code> variable or using <code>send(_:)</code> method.</li>
</ul>
<h2 id=memory-management>Memory management</h2>
<p>If you look closely at the code examples in the first section, you‚Äôll notice the retaining of <code>AnyCancellable</code> after creating subscriptions. Methods¬†<code>.sink</code> and¬†<code>.assign(to:on:)</code> both return <code>AnyCancellable</code>, indicating that the subscriptions can be cancelled from outside. This retaining is important to keep the created data streams alive; and also to dispose them when they are no longer relevant - much like how <code>DisposeBag</code> is used in RxSwift.</p>
<p>Usually you would want to create more than one subscriptions in a class, so it is more practical to have a set of <code>AnyCancellable</code> objects to keep all the subscriptions in one place:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RepoDetailViewController</span>: UIViewController {
    <span style=color:#66d9ef>@IBOutlet</span> <span style=color:#66d9ef>var</span> titleLabel: UILabel!
    <span style=color:#66d9ef>@IBOutlet</span> <span style=color:#66d9ef>var</span> descriptionLabel: UILabel!
    <span style=color:#66d9ef>var</span> viewModel: RepoDetailViewModel!
    <span style=color:#66d9ef>var</span> cancellables: Set&lt;AnyCancellable&gt; = []
    
    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>viewDidLoad</span>() {
        <span style=color:#66d9ef>super</span>.viewDidLoad()
        viewModel.<span style=color:#960050;background-color:#1e0010>$</span>repoDetail
            .map { $0?.name }
            .assign(to: <span style=color:#960050;background-color:#1e0010>\</span>.text, on: titleLabel)
            .store(<span style=color:#66d9ef>in</span>: &amp;cancellables)
        
        viewModel.<span style=color:#960050;background-color:#1e0010>$</span>repoDetail
            .map { $0?.description }
            .assign(to: <span style=color:#960050;background-color:#1e0010>\</span>.text, on: descriptionLabel)
            .store(<span style=color:#66d9ef>in</span>: &amp;cancellables)

		viewModel.fetchRepoDetails()
    }
}
</code></pre></div><p>Here the lifecycle of <code>cancellablles</code> is tied with <code>RepoDetailViewController</code>, so when the view controller is released, the subscriptions stored in this property will all be cancelled and disposed as well.</p>
<p>But how about the method <code>assign(to:)</code>? Why didn&rsquo;t I retain the subscription made with it like I did with the other two methods?</p>
<img src=https://media.giphy.com/media/UDFMOnaOrLx28/giphy.gif alt=https://media.giphy.com/media/UDFMOnaOrLx28/giphy.gif class=center>
<p>As you may have guessed, this method links the created subscription with the <code>@Published</code> property sent to it, so it does not require the same memory managment machanism as the two methods discussed earlier.</p>
<h2 id=type-matching-and-errorhandling>Type matching and error¬†handling</h2>
<p>In RxSwift, Observable is a generic type with an associated type Element defining the type of the data stream‚Äôs output. In Combine, a Publisher has two concerns: Output and Failure types. Failure type of a publisher can be either an <code>Error</code>-conforming type, or <code>Never</code> if it does not publish any error. So when creating a subscription, you have to make sure that the Input type of the subscriber match with the Output type of the publisher. More interestingly, their Failure types are also required to be the same, otherwise you&rsquo;ll encounter a mismatching types error.</p>
<p>Publisher extension has several operators to handle errors. In the <code>fetchRepoDetail()</code> example above I used <code>replaceError(with:)</code> to silent any decoding or response errors with <code>nil</code> since I wanted the failure type of the upstream publisher to match with that of the <code>@Published</code> property, which is <code>Never</code>. In cases when you are certain that no error should be thrown, <code>assertNoFailure()</code> can be used to transform failure type to <code>Never</code> or call assert otherwise. You can also use <code>retry()</code> to attempt recreating failed subscriptions to a specified number of times; or map the error to another publisher using <code>catch()</code>.</p>
<p>In real life situations, however, error handling is more often necessary‚Ää‚Äî‚Äähere‚Äôs how the code can be refactored for that purpose:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>RepoError</span>: Error {
    <span style=color:#66d9ef>case</span> url(URLError)
    <span style=color:#66d9ef>case</span> decode
    <span style=color:#66d9ef>case</span> unknown
}

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RepoDetailViewModel</span> {
    <span style=color:#66d9ef>let</span> repoDetailSubject = CurrentValueSubject&lt;Repo?, RepoError&gt;(<span style=color:#66d9ef>nil</span>)
    
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> cancellable: Cancellable?
    
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>fetchRepoDetails</span>() {
        <span style=color:#66d9ef>let</span> url = URL(string: <span style=color:#e6db74>&#34;https://api.github.com/repos/itsmeichigo/Playgrounds&#34;</span>)<span style=color:#f92672>!</span>
        cancellable = URLSession.shared.dataTaskPublisher(<span style=color:#66d9ef>for</span>: url)
            .tryMap(<span style=color:#960050;background-color:#1e0010>\</span>.data)
            .decode(type: Repo?.<span style=color:#66d9ef>self</span>, decoder: JSONDecoder())
            .mapError { error -&gt; RepoError <span style=color:#66d9ef>in</span>
                <span style=color:#66d9ef>switch</span> error {
                <span style=color:#66d9ef>case</span> <span style=color:#66d9ef>is</span> URLError:
                    <span style=color:#66d9ef>return</span> .url(error <span style=color:#66d9ef>as</span>! URLError)
                <span style=color:#66d9ef>case</span> <span style=color:#66d9ef>is</span> DecodingError:
                    <span style=color:#66d9ef>return</span> .decode
                <span style=color:#66d9ef>default</span>:
                    <span style=color:#66d9ef>return</span> .unknown
                }
            }
            .sink { [<span style=color:#66d9ef>weak</span> <span style=color:#66d9ef>self</span>] completion <span style=color:#66d9ef>in</span>
                <span style=color:#66d9ef>self</span>?.repoDetailSubject.send(completion: completion)
            } receiveValue: { [<span style=color:#66d9ef>weak</span> <span style=color:#66d9ef>self</span>] repos <span style=color:#66d9ef>in</span>
                <span style=color:#66d9ef>self</span>?.repoDetailSubject.send(repos)
            }
    }
}
</code></pre></div><p>In the above solution, I‚Äôve changed the <code>@Published</code> property to a <code>CurrentValueSubject</code> to change the error type from <code>Never</code> to <code>RepoError</code>. Then I used <code>mapError</code> function to transform the errors from upstream to my custom error type <code>RepoError</code>. The result publisher was finally subscribed using a <code>Sink</code> to send values and completion event to the subject. It&rsquo;s a pity that we cannot use <code>assign(to:)</code> with a subject like how we can bind observables to subjects or observers in RxSwift - but we can further improve this piece of code in the next section.</p>
<h2 id=type-eraser>Type eraser</h2>
<p>A quick look at the <a href=https://developer.apple.com/documentation/combine/publisher>Apple documentation of Publisher</a> can show that most operators used on publishers return their respective types extending the <code>Publishers</code> enum. Take the code snippet from the previous section as an example, if you paste it in a Playground and open Quick Help panel to investigate the returned types of each operator, you&rsquo;ll be surprised how the types can get more and more complicated after each operator:</p>
<ul>
<li><code>URLSession.shared.dataTaskPublisher</code> returns publisher of type <code>DataTaskPublisher</code></li>
<li>applying <code>tryMap</code>, we get the result of type <code>Publishers.TryMap&lt;URLSession.DataTaskPublisher, T></code></li>
<li>moving on with <code>decode</code>, we get <code>Publishers.Decode&lt;Publishers.TryMap&lt;URLSession.DataTaskPublisher, Data>, Item, Coder> where Item¬†: Decodable, Coder¬†: TopLevelDecoder, Self.Output == Coder.Input</code></li>
<li>finally, with <code>mapError</code> we end up with <code>Publishers.MapError&lt;Publishers.Decode&lt;Publishers.TryMap&lt;URLSession.DataTaskPublisher, Data>, Repo?, JSONDecoder>, E></code></li>
</ul>
<p>If we want to expose the publisher to external subscribers, we‚Äôll need a more generic type - <code>AnyPublisher</code> - as the subscribers only concern about the output and failure types of the publisher they subscribe to. This is where type erasing comes to play, and Combine has a method for this: <code>eraseToAnyPublisher()</code>. Let&rsquo;s see how we can use this to improve the implementation in the previous section:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>fetchDetail</span>() -&gt; AnyPublisher&lt;Repo, RepoError&gt; {
    <span style=color:#66d9ef>let</span> url = URL(string: <span style=color:#e6db74>&#34;https://api.github.com/repos/itsmeichigo/Playgrounds&#34;</span>)<span style=color:#f92672>!</span>
    <span style=color:#66d9ef>return</span> URLSession.shared.dataTaskPublisher(<span style=color:#66d9ef>for</span>: url)
        .tryMap(<span style=color:#960050;background-color:#1e0010>\</span>.data)
        .decode(type: Repo.<span style=color:#66d9ef>self</span>, decoder: JSONDecoder())
        .mapError { error -&gt; RepoError <span style=color:#66d9ef>in</span>
            <span style=color:#66d9ef>switch</span> error {
            <span style=color:#66d9ef>case</span> <span style=color:#66d9ef>is</span> URLError:
                <span style=color:#66d9ef>return</span> .url(error <span style=color:#66d9ef>as</span>! URLError)
            <span style=color:#66d9ef>case</span> <span style=color:#66d9ef>is</span> DecodingError:
                <span style=color:#66d9ef>return</span> .decode
            <span style=color:#66d9ef>default</span>:
                <span style=color:#66d9ef>return</span> .unknown
            }
        }
        .eraseToAnyPublisher()
}
</code></pre></div><p>This time, a publisher is returned immediately from <code>fetchDetail()</code> function, and the <code>RepoDetailViewController</code> can subscribe directly to it and handle any received events. I can then safely remove redundant use and subscription of <code>CurrentValueSubject</code>, and the code looks much neater. The returned publisher is of type <code>AnyPublisher&lt;Repo?, RepoError></code>, which is informative enough for any external subscribers.</p>
<h2 id=future-anddeferred>Future and¬†Deferred</h2>
<p>In Combine, many publishers invoke their closures and emit values only after they get a subscription. For instance, a <code>DataTaskPublisher</code> starts a url request and emit subsequent result whenever it receives demand request from a subscriber. This also means that several subscriptions made to the same publisher can trigger multiple url requests and receive different response - which is not desirable if we just want to observe the same stream. Applying <code>share()</code> operator can solve that problem, making sure that the same output of the publisher is shared among its subscribers.</p>
<p>An alternative would be to wrap the <code>URLSessionDataTask</code> creation in a <code>Future</code>. It&rsquo;s a type of publisher that completes after emitting a <strong>single</strong> output value or failure. This result is republished to any subscriber listens to the same <code>Future</code> object. It&rsquo;s suitable for wrapping any asynchronous work that expects only one result. Since a url requests always returns response once and then completes - this is a perfect case for the use of <code>Future</code>:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>fetchDetail</span>() -&gt; Future&lt;Repo, RepoError&gt; {
    <span style=color:#66d9ef>let</span> url = URL(string: <span style=color:#e6db74>&#34;https://api.github.com/repos/itsmeichigo/Playgrounds&#34;</span>)<span style=color:#f92672>!</span>
    <span style=color:#66d9ef>return</span> Future { promise <span style=color:#66d9ef>in</span>
        URLSession.shared.dataTask(with: url) { (data, response, error) <span style=color:#66d9ef>in</span>
            <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> error = error <span style=color:#66d9ef>as</span>? URLError {
                promise(.failure(.url(error)))
            } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> data = data {
                <span style=color:#66d9ef>do</span> {
                    <span style=color:#66d9ef>let</span> decoder = JSONDecoder()
                    <span style=color:#66d9ef>let</span> detail = <span style=color:#66d9ef>try</span> decoder.decode(Repo.<span style=color:#66d9ef>self</span>, from: data)
                    promise(.success(detail))
                } <span style=color:#66d9ef>catch</span> {
                    promise(.failure(.decode))
                }
            } <span style=color:#66d9ef>else</span> {
                promise(.failure(.unknown))
            }
        }.resume()
    }
}
</code></pre></div><p>Using <code>Future</code> requires extra caution though, especially if you apply <code>eraseToAnyPublisher()</code> as developers on the receiving end may not be aware of its distinctive features:</p>
<ul>
<li><code>Future</code> immediately invokes the asynchronous request in its closure at the time of creation.</li>
<li><code>Future</code> emits result only once so even though it&rsquo;s still possible to call <code>retry()</code> on it, the operator can&rsquo;t create new subscription after the publisher completes.</li>
</ul>
<p>A solution to delay the start of a <code>Future</code>&rsquo;s work while still taking advantage of its one-time result is to wrap it inside a <code>Deferred</code>. This is another special kind of publisher whose job is to wait for a subscription before triggering the supplied closure to create a new publisher. The implementation is simple:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>createDeferred</span>() -&gt; Deferred&lt;Future&lt;Repo, RepoError&gt;<span style=color:#f92672>&gt;</span> {
    Deferred {
        Future { promise <span style=color:#66d9ef>in</span>
            <span style=color:#75715e>// The rest of implementation</span>
        }
    }
}
</code></pre></div><p>With the use of <code>Deferred</code>, a new <code>Future</code> object is created every time there&rsquo;s a new subscription, making the <code>Future</code> lazy - which is more similar to <code>Single</code> in RxSwift.</p>
<h2 id=backpressure>Backpressure</h2>
<p>I cannot end this article without mentioning backpressure. It defines the core principle of Combine: In a subscription, the subscriber controls the handling of events from the upstream publisher, including number of values to be received. As per the documentation on Publisher protocol, the following methods of the subscriber will be triggerred when it listens to a publisher:</p>
<ul>
<li><code>receive(subscription:)</code>: Notifies the subscriber of a succesful subscribe request and returns a <code>Subscription</code> instance. The subscriber uses this subscription object to request a <code>Subscriber.Demands</code> specifying the number items to receive, if any.</li>
<li><code>receive(_:)</code>: Delivers one element from the publisher to the subscriber. This methods returns another <code>Subscriber.Demands</code> to let the publisher know if any more demand for is needed.</li>
<li><code>receive(completion:)</code>: Informs the subscriber that publishing has ended, either normally or with an error.</li>
</ul>
<p>The specification of demands makes sure that the subscription sends just enough items as requested by the subscriber and no more. Below is an illustration for a <code>Sink</code> subscriber to visualize the relationship and clarify the explanations a little further (apologies for my poor drawing skills üôÇ):</p>
<p><img src=combine-carbon.png alt=Illustration></p>
<p>Backpressure is an advanced topic and as Apple keeps their implementations of publishers and subscribers private, the complexity of this management is hidden from developers. Understanding the principle of backpressure makes customization for publishers and subscribers possible. One particular use case for this is <a href=https://github.com/CombineCommunity/CombineCocoa>CombineCocoa by CombineCommunity</a>, which makes integration of Combine when using UIControls much more convenient. However, Apple strongly encourages that developers use the built-in convenience publishers and subjects instead of implementing custom ones, so it is important to look for simple solutions before tempting to overengineer to avoid bringing complexity and potential bugs to your projects.</p>
<h2 id=epilogue>Epilogue</h2>
<p>Since Combine only supports iOS 13 onwards, it may be a bit early for most of current projects to adopt. Nevertheless, it‚Äôs never too soon to learn new tech and start experimenting with it to get yourself comfortable and ‚Äúrelevant‚Äù. The framework itself is still under development and improvement, so don‚Äôt forget to check back in future WWDCs for any cool new updates. I hope this article inspires you to dive deeper and learn more about Combine. I would like to give my thanks to <a href=https://twitter.com/DonnyWals>Donny Wals</a> for his book <a href=https://gumroad.com/donnywals#XVbKP>Practical Combine</a>, as well as all the resources listed in the References section for making this article possible. In the meantime, you can also check out <a href=https://github.com/CombineCommunity/RxCombine>RxCombine</a> to discover the possiblities of bridging between the two frameworks. Have fun!</p>
<h2 id=references>References</h2>
<p><a href=https://developer.apple.com/documentation/combine>Apple Developer Documentation</a></p>
<p><a href=https://www.avanderlee.com/swift/combine/>Getting started with the Combine framework in Swift - SwiftLee</a></p>
<p><a href=https://github.com/CombineCommunity/rxswift-to-combine-cheatsheet>CombineCommunity/rxswift-to-combine-cheatsheet</a></p>
<p><a href=https://heckj.github.io/swiftui-notes/>Using Combine</a></p>
<p><a href=https://www.apeth.com/UnderstandingCombine/>Understanding Combine</a></p>
</div>
</article>
<hr>
<div class=post-info>
<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg>
<span class=tag><a href=/tags/swift/>swift</a></span>
<span class=tag><a href=/tags/rxswift/>rxswift</a></span>
<span class=tag><a href=/tags/combine/>combine</a></span>
</p>
<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>
2517 Words
</p>
<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2020-12-16 14:23
</p>
</div>
<hr>
<div class=sharing-buttons>
<a class=resp-sharing-button__link href="https://facebook.com/sharer/sharer.php?u=%2fposts%2fcombine-from-rxswift%2f" target=_blank rel=noopener aria-label title="Share on facebook">
<div class="resp-sharing-button resp-sharing-button--facebook resp-sharing-button--small"><div aria-hidden=true class="resp-sharing-button__icon resp-sharing-button__icon--solid"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 2h-3a5 5 0 00-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 011-1h3z"/></svg>
</div>
</div>
</a>
<a class=resp-sharing-button__link href="https://twitter.com/intent/tweet/?url=%2fposts%2fcombine-from-rxswift%2f" target=_blank rel=noopener aria-label title="Share on twitter">
<div class="resp-sharing-button resp-sharing-button--twitter resp-sharing-button--small">
<div aria-hidden=true class="resp-sharing-button__icon resp-sharing-button__icon--solid"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg>
</div>
</div>
</a>
<a class=resp-sharing-button__link href="mailto:?subject=Combine%20from%20RxSwift%20-%20Highlights%20for%20smooth%20adaption&body=%2fposts%2fcombine-from-rxswift%2f" target=_self rel=noopener aria-label title="Share via email">
<div class="resp-sharing-button resp-sharing-button--email resp-sharing-button--small"><div aria-hidden=true class="resp-sharing-button__icon resp-sharing-button__icon--solid"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16c1.1.0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1.0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg>
</div>
</div>
</a>
</div>
<div class=pagination>
<div class=pagination__title>
<span class=pagination__title-h>Read other posts</span>
<hr>
</div>
<div class=pagination__buttons>
<span class="button previous">
<a href=/posts/breaking-down-pull-requests/>
<span class=button__icon>‚Üê</span>
<span class=button__text>Breaking down large pull requests</span>
</a>
</span>
<span class="button next">
<a href=/posts/swiftui-happy-panel/>
<span class=button__text>Learning SwiftUI by Building a Slack-like Emoji Picker</span>
<span class=button__icon>‚Üí</span>
</a>
</span>
</div>
</div>
</main>
</div>
<footer class=footer>
<div class=footer__inner>
<div class=footer__content>
<span>&copy; 2022</span>
<span>Huong Do</span>
<span><a href=/posts/index.xml target=_blank title=rss><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></span>
</div>
</div>
</footer>
</div>
<script type=text/javascript src=/bundle.min.a0f363fdf81cdc5cfacc447a79c33189eb000d090336cd04aac8ee256f423b3133b836c281944c19c75e38d0b0b449f01ce5807e37798b7ac94ac1db51983fc4.js integrity="sha512-oPNj/fgc3Fz6zER6ecMxiesADQkDNs0EqsjuJW9COzEzuDbCgZRMGcdeONCwtEnwHOWAfjd5i3rJSsHbUZg/xA=="></script>
</body>
</html>