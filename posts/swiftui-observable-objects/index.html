<!doctype html><html lang=en><head><meta charset=UTF-8><meta http-equiv=X-UA-Compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content><meta name=description content='Earlier this week I learned about @StateObject initializer when reviewing a pull request. The idea was to create a view model for a SwiftUI view using some injected parameter and keep the view model as a @StateObject so that the its state is persisted when the view is redrawn. The view creates the @StateObject like so:
class ItemViewModel: ObservableObject { @Published var itemName: String init(item: Item) { self.itemName = item.name } } struct ItemView: View { @StateObject private var viewModel: ItemViewModel init(item: Item) { _viewModel = StateObject(wrappedValue: ItemViewModel(item: item)) } var body: some View { TextField("Item Name", text: viewModel.$itemName) } } The problem with this initializer is that it&rsquo;s not meant to be used directly. As Apple documentation says it:
'><meta name=keywords content="itsmeichigo,blog,apps,swift,swiftui,observedobject,stateobject"><meta name=robots content="noodp"><meta name=theme-color content><link rel=canonical href=/posts/swiftui-observable-objects/><title>Working with observable objects in SwiftUI | Huong Do</title><link rel=stylesheet href=/main.min.b40b8806a3821a94f2961fb4f44a1bd3bbf354ce3fdec68ee7c36a02d45e713c.css integrity="sha256-tAuIBqOCGpTylh+09Eob07vzVM4/3saO58NqAtRecTw=" crossorigin=anonymous><meta itemprop=name content="Working with observable objects in SwiftUI"><meta itemprop=description content='Earlier this week I learned about @StateObject initializer when reviewing a pull request. The idea was to create a view model for a SwiftUI view using some injected parameter and keep the view model as a @StateObject so that the its state is persisted when the view is redrawn. The view creates the @StateObject like so:
class ItemViewModel: ObservableObject { @Published var itemName: String init(item: Item) { self.itemName = item.name } } struct ItemView: View { @StateObject private var viewModel: ItemViewModel init(item: Item) { _viewModel = StateObject(wrappedValue: ItemViewModel(item: item)) } var body: some View { TextField("Item Name", text: viewModel.$itemName) } } The problem with this initializer is that it‚Äôs not meant to be used directly. As Apple documentation says it:'><meta itemprop=datePublished content="2021-09-11T10:00:02+07:01"><meta itemprop=dateModified content="2021-09-11T10:00:02+07:01"><meta itemprop=wordCount content="641"><meta itemprop=image content="/"><meta itemprop=keywords content="Swift,Swiftui,Observedobject,Stateobject"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="/"><meta name=twitter:title content="Working with observable objects in SwiftUI"><meta name=twitter:description content='Earlier this week I learned about @StateObject initializer when reviewing a pull request. The idea was to create a view model for a SwiftUI view using some injected parameter and keep the view model as a @StateObject so that the its state is persisted when the view is redrawn. The view creates the @StateObject like so:
class ItemViewModel: ObservableObject { @Published var itemName: String init(item: Item) { self.itemName = item.name } } struct ItemView: View { @StateObject private var viewModel: ItemViewModel init(item: Item) { _viewModel = StateObject(wrappedValue: ItemViewModel(item: item)) } var body: some View { TextField("Item Name", text: viewModel.$itemName) } } The problem with this initializer is that it‚Äôs not meant to be used directly. As Apple documentation says it:'><meta property="og:url" content="/posts/swiftui-observable-objects/"><meta property="og:site_name" content="Huong Do"><meta property="og:title" content="Working with observable objects in SwiftUI"><meta property="og:description" content='Earlier this week I learned about @StateObject initializer when reviewing a pull request. The idea was to create a view model for a SwiftUI view using some injected parameter and keep the view model as a @StateObject so that the its state is persisted when the view is redrawn. The view creates the @StateObject like so:
class ItemViewModel: ObservableObject { @Published var itemName: String init(item: Item) { self.itemName = item.name } } struct ItemView: View { @StateObject private var viewModel: ItemViewModel init(item: Item) { _viewModel = StateObject(wrappedValue: ItemViewModel(item: item)) } var body: some View { TextField("Item Name", text: viewModel.$itemName) } } The problem with this initializer is that it‚Äôs not meant to be used directly. As Apple documentation says it:'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-09-11T10:00:02+07:01"><meta property="article:modified_time" content="2021-09-11T10:00:02+07:01"><meta property="article:tag" content="Swift"><meta property="article:tag" content="Swiftui"><meta property="article:tag" content="Observedobject"><meta property="article:tag" content="Stateobject"><meta property="og:image" content="/"><meta property="article:published_time" content="2021-09-11 10:00:02 +0701 +0701"></head><body class=dark-theme><div class=container><header class=header><span class=header__inner><a href=/ style=text-decoration:none><div class=logo><span class=logo__mark>></span>
<span class=logo__text>cd home/</span>
<span class=logo__cursor></span></div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=/about>about</a></li><li><a href=/apps>apps</a></li><li><a href=/posts>posts</a></li></ul></nav><span class=menu-trigger><svg viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>
</span><span class="theme-toggle unselectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><main class=post><div class=post-info><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
4 minutes</p></div><article><h1 class=post-title><a href=/posts/swiftui-observable-objects/>Working with observable objects in SwiftUI</a></h1><div class=post-content><p>Earlier this week I learned about <code>@StateObject</code> <a href=https://developer.apple.com/documentation/swiftui/stateobject/init%28wrappedvalue:%29>initializer</a> when reviewing a pull request. The idea was to create a view model for a SwiftUI view using some injected parameter and keep the view model as a <code>@StateObject</code> so that the its state is persisted when the view is redrawn. The view creates the <code>@StateObject</code> like so:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ItemViewModel</span>: ObservableObject {
</span></span><span style=display:flex><span>    @Published <span style=color:#66d9ef>var</span> itemName: String
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>init</span>(item: Item) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>self</span>.itemName = item.name
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>ItemView</span>: View {
</span></span><span style=display:flex><span>    @StateObject <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> viewModel: ItemViewModel
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>init</span>(item: Item) {
</span></span><span style=display:flex><span>        _viewModel = StateObject(wrappedValue: ItemViewModel(item: item))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> body: some View {
</span></span><span style=display:flex><span>        TextField(<span style=color:#e6db74>&#34;Item Name&#34;</span>, text: viewModel.<span style=color:#960050;background-color:#1e0010>$</span>itemName)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The problem with this initializer is that it&rsquo;s not meant to be used directly. As Apple documentation says it:</p><blockquote><p>You don‚Äôt call this initializer directly. Instead, declare a property with the <code>@StateObject</code> attribute in a <a href=https://developer.apple.com/documentation/swiftui/view><code>View</code></a>, <a href=https://developer.apple.com/documentation/swiftui/app><code>App</code></a>, or <a href=https://developer.apple.com/documentation/swiftui/scene><code>Scene</code></a>, and provide an initial value</p></blockquote><p>More interestingly, <a href=https://swiftui-lab.com/random-lessons/#data-10>an answer</a> on the WWDC21&rsquo;s SwiftUI Lab confirms that this is an acceptable use. I&rsquo;m not quite happy with this answer though, because it&rsquo;s not cool to go against the recommended use. So we can fix this by injecting the view model from outside, right?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>ItemView</span>: View {
</span></span><span style=display:flex><span>    @StateObject <span style=color:#66d9ef>var</span> viewModel: ItemViewModel
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> body: some View {
</span></span><span style=display:flex><span>        Text(<span style=color:#e6db74>&#34;Test: </span><span style=color:#e6db74>\(</span>viewModel.id<span style=color:#e6db74>)</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>ItemListView</span>: View {
</span></span><span style=display:flex><span>    @ObservedObject <span style=color:#66d9ef>var</span> viewModel: ItemListViewModel
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> body: some View {
</span></span><span style=display:flex><span>        ForEach(viewModel.items) { item <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>            ItemView(viewModel: ItemViewModel(item: item))
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>But this doesn&rsquo;t seem right!</p><p>I&rsquo;ve read several articles about the difference between <code>@StateObject</code> and <code>@ObservedObject</code>, and the general idea is simple: You should use <code>@StateObject</code> if the view you&rsquo;re using creates the instance of the <code>ObservableObject</code> itself. If it does not, use <code>@ObservedObject</code> instead.</p><p>Consider <code>@StateObject</code> something similar to <code>@State</code> but to use with <code>ObservableObject</code>. They both are created and owned by the SwiftUI view. Their values are controlled internally and persisted by SwiftUI internally throughout re-renders of the view. <code>@ObservedObject</code>, however, is not persisted by SwiftUI.</p><p>Back to our initial code problem. Using the injected <code>@StateObject</code> is incorrect, so we should go ahead and replace it with <code>@ObservedObject</code>. Normally we&rsquo;re done here, since we usually want fresh instances of items every time a list redraws itself.</p><p>But what if we want to keep the text field value when rotating the device? When device orientation changes, the item list is redrawn, which creates new views for the child items with new instances of their view models. This will reset the content of a <code>ItemView</code>&rsquo;s text field to its initial value.</p><p>The solution is to hold on the the item view models to persist the state of the item views:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ItemListViewModel</span>: ObservableObject {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span>(<span style=color:#66d9ef>set</span>) <span style=color:#66d9ef>var</span> itemViewModels: [ItemViewModel]
</span></span><span style=display:flex><span>    @Published <span style=color:#66d9ef>var</span> items: [Item]
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>init</span>(items: Item) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>self</span>.items = items
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>self</span>.itemViewModel = items.map { ItemViewModel(item: $0) }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>ItemListView</span>: View {
</span></span><span style=display:flex><span>    @ObservedObject <span style=color:#66d9ef>var</span> viewModel: ItemListViewModel
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> body: some View {
</span></span><span style=display:flex><span>        ForEach(viewModel.items) { item <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>            viewModel.itemViewModels.first(<span style=color:#66d9ef>where</span>: { $0.item == item }).map { viewModel <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>                ItemView(viewModel: viewModel)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>ItemView</span>: View {
</span></span><span style=display:flex><span>    @ObservedObject <span style=color:#66d9ef>var</span> viewModel: ItemViewModel
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> body: some View {
</span></span><span style=display:flex><span>        Text(<span style=color:#e6db74>&#34;Test: </span><span style=color:#e6db74>\(</span>viewModel.id<span style=color:#e6db74>)</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Since our <code>ItemListViewModel</code> now keeps references of all the items&rsquo; view models, the text field of each item view is kept intact when the view is redrawn! üéâ</p><p>So whenever you find yourself needing an <code>ObservableObject</code> in a SwiftUI view, ask yourself two questions:</p><ul><li>Do I need <strong>external (injected) data</strong> to create the object? If yes, go for <code>@ObservedObject</code>, otherwise <code>@StateObject</code>.</li><li>I need to use an <code>@ObservedObject</code>, but do I need to <strong>persist its states</strong>? If yes, keep a reference of the object somewhere, otherwise, feel free to create a new instance for every view.</li></ul><p>I hope these tips are helpful for other folks working with SwiftUI in their projects!</p><p>More readings if you&rsquo;re interested:</p><ul><li><a href=https://swiftuipropertywrappers.com/>SwiftUI Property Wrappers</a></li><li><a href=https://www.donnywals.com/whats-the-difference-between-stateobject-and-observedobject/>What&rsquo;s the difference between @StateObject and @ObservedObject?</a></li><li><a href=https://sarunw.com/posts/how-to-initialize-stateobject-with-parameters-in-swiftui/>How to initialize @StateObject with parameters in SwiftUI</a></li></ul></div></article><hr><div class=post-info><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg>
<span class=tag><a href=/tags/swift/>swift</a></span>
<span class=tag><a href=/tags/swiftui/>swiftui</a></span>
<span class=tag><a href=/tags/observedobject/>observedobject</a></span>
<span class=tag><a href=/tags/stateobject/>stateobject</a></span></p><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>
641 Words</p><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2021-09-11 02:59</p></div><hr><div class=sharing-buttons><a class=resp-sharing-button__link href="https://facebook.com/sharer/sharer.php?u=%2fposts%2fswiftui-observable-objects%2f" target=_blank rel=noopener aria-label title="Share on facebook"><div class="resp-sharing-button resp-sharing-button--facebook resp-sharing-button--small"><div aria-hidden=true class="resp-sharing-button__icon resp-sharing-button__icon--solid"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 2h-3a5 5 0 00-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 011-1h3z"/></svg></div></div></a><a class=resp-sharing-button__link href="https://twitter.com/intent/tweet/?url=%2fposts%2fswiftui-observable-objects%2f" target=_blank rel=noopener aria-label title="Share on twitter"><div class="resp-sharing-button resp-sharing-button--twitter resp-sharing-button--small"><div aria-hidden=true class="resp-sharing-button__icon resp-sharing-button__icon--solid"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></div></div></a><a class=resp-sharing-button__link href="mailto:?subject=Working%20with%20observable%20objects%20in%20SwiftUI&amp;body=%2fposts%2fswiftui-observable-objects%2f" target=_self rel=noopener aria-label title="Share via email"><div class="resp-sharing-button resp-sharing-button--email resp-sharing-button--small"><div aria-hidden=true class="resp-sharing-button__icon resp-sharing-button__icon--solid"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16c1.1.0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1.0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg></div></div></a></div><div class=pagination><div class=pagination__title><span class=pagination__title-h></span><hr></div><div class=pagination__buttons><span class="button previous"><a href=/posts/peachy/><span class=button__icon>‚Üê</span>
<span class=button__text>Releasing Peachy üçë</span>
</a></span><span class="button next"><a href=/posts/breaking-down-pull-requests/><span class=button__text>Breaking down large pull requests</span>
<span class=button__icon>‚Üí</span></a></span></div></div></main></div><footer class=footer><div class=footer__inner><div class=footer__content><span>&copy; 2025</span>
<span>Huong Do</span>
<span><a href=/posts/index.xml target=_blank title=rss><svg width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></span></div></div></footer></div><script type=text/javascript src=/bundle.min.f0a83284a6a9c303ebdedda40cff4fae081def9d6a9799f08d51f2779bc03f8a9c5b606d59895c8c0cd5297ce84850caae34b98aace4b455e992310ed26193ba.js integrity="sha512-8KgyhKapwwPr3t2kDP9Prggd751ql5nwjVHyd5vAP4qcW2BtWYlcjAzVKXzoSFDKrjS5iqzktFXpkjEO0mGTug=="></script></body></html>