<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Tea with ichigo üçµ</title><link>/posts/</link><description>Recent content in Posts on Tea with ichigo üçµ</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Huong Do</copyright><lastBuildDate>Tue, 13 Jul 2021 17:02:02 +0700</lastBuildDate><atom:link href="/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Breaking down large pull requests</title><link>/posts/breaking-down-pull-requests/</link><pubDate>Tue, 13 Jul 2021 17:02:02 +0700</pubDate><guid>/posts/breaking-down-pull-requests/</guid><description>This post was originally posted in WooCommerce Mobile Project P2 page. I figure this can be useful for other fellow developers as well so this is my public version of the post.
Usually we have several teams working on different features, and we break down tasks into bite-size ones ‚Äì so large PRs aren‚Äôt really a problem. However, for folks working alone on a backlog story, or joining the team for General Maintenance Rotation, and especially Trialmatticians ‚Äì it‚Äôs common to face the issue of handling a big task and having to break them down into smaller parts.</description><content type="html"><![CDATA[<p><em>This post was originally posted in WooCommerce Mobile Project <a href="https://wordpress.com/p2/">P2</a> page. I figure this can be useful for other fellow developers as well so this is my public version of the post.</em></p>
<p>Usually we have several teams working on different features, and we break down tasks into bite-size ones ‚Äì so large PRs aren‚Äôt really a problem. However, for folks working alone on a backlog story, or joining the team for General Maintenance Rotation, and especially Trialmatticians ‚Äì it‚Äôs common to face the issue of handling a big task and having to break them down into smaller parts. So what are the best practices for this situation?</p>
<h2 id="feature-branch-yay-or-nay">Feature Branch: Yay or Nay?</h2>
<p>In my previous gig, we had around 10 teams working on the same mono-repo project, so we maintained feature branches for each team. My take on this approach:</p>
<p>üéâ Yay: Each team has a separate space to work on their features.
ü§¶‚Äç‚ôÄÔ∏è Nay: It can be a pain when merging a long-lived branch, considering potential conflicts in terms of code and features. For example: a team can merge some fix that affects another team and that somehow slips through the crack. When the second team merges their feature, they discover the issue but it may be so close to the deadline and everyone gets panic! üí£üí•</p>
<p>So it seems like there are more cons than pros to me.</p>
<h2 id="early-merges-to-develop-branch">Early merges to develop branch</h2>
<p>Another solution is breaking down tasks and handling them in separate small PRs, which are merged into develop sequentially. Spoiler alert: this is preferred considering our team size and our strong emphasis on transparency. There are quite a few things to consider though:</p>
<ul>
<li><strong>Careful planning</strong> is highly recommended. When starting with a big task, it is important to separate them into smaller bits. You can start by considering changes you‚Äôll need to make to networking, storage, logic and UI layers. If your task focuses only on the UI layer, you can break it down into even smaller features. This will help with making sure PRs are focused and small, so that it‚Äôs easier for your teammate to review.</li>
<li>Work on <strong>non-user-facing tasks first</strong>. These have less affects on the app when merged, and usually are essential to be merged early to avoid conflicts (take Core Data versioning for example).</li>
<li>For user-facing changes, if your PR does not complete the feature, <strong>consider a feature flag</strong> to hide the feature from user. At WooCommerce mobile teams we have special tag <a href="https://github.com/woocommerce/woocommerce-ios/labels?q=feature-flagged">status: feature-flag</a> that can be used to let the team know that a feature is not yet available for testing on release builds.</li>
<li>Usually a PR can take some time to get merged and you want to work on another to unblock yourself. A good approach is to <strong>create a new PR basing on the previous PR‚Äôs branch</strong>. There&rsquo;s a really cool feature of Github that when the base branch is merged to develop, the dependent PR‚Äôs base will automatically change to develop!</li>
<li>It can be a good practice to tag your dependent PRs as <code>do not merge</code>, to make sure that they are not accidentally merged before their parent PR. Some may prefer to keep the dependent PRs as drafts instead. I myself prefer the former ‚Äì just so my teammates can review all PRs as soon as they can (like concurrency in programming üòÇ).</li>
</ul>
<p>In the end, if you have a number of pull requests depending on one another, you should have a chain like this:
<img src="PRs.png" alt="Dependend Pull Requests"></p>
<p>In my case, I‚Äôm not sure if my PRs can get merged before code freeze, so I‚Äôm keeping the flag on only for local development (and off for both beta testing and production). You can consider keeping your flag off on local too if it can block other teammates when they need to run the old feature. Just make sure to include instructions to turn the flag on in the testing steps of your PR.</p>
<h2 id="final-thoughts">Final thoughts</h2>
<p>In conclusion, I want to highlight the 3 main takeaways of this post:</p>
<ul>
<li>Always keep your PRs small and focused.</li>
<li>It‚Äôs important to keep develop branch updated with your changes as early on as possible.</li>
<li>Feature flags are powerful for developing user-facing features.</li>
</ul>
<p>I hope this post is helpful for other developers to when working with pull requests. If you have more suggestions for best practices of pull requests, do reach out to me via <a href="https://twitter.com/itsmeichigo">Twitter</a>!</p>
<p>Until next time üëã</p>
]]></content></item><item><title>Combine from RxSwift - Highlights for smooth adaption</title><link>/posts/combine-from-rxswift/</link><pubDate>Wed, 16 Dec 2020 21:23:02 +0700</pubDate><guid>/posts/combine-from-rxswift/</guid><description>RxSwift has been around since 2015 and widely known among Apple developer community as an efficient open-sourced FRP library. In WWDC 2019 Apple introduced their very own FRP framework, making it possible to utilize the paradigm natively with declarative Swift API. The two frameworks share quite a few similarities in terms of principles and usage, so it can be not too daunting to get your feet wet with Combine if you have already been using RxSwift in your projects.</description><content type="html"><![CDATA[<p>RxSwift has been around since 2015 and widely known among Apple developer community as an efficient open-sourced FRP library. In WWDC 2019 Apple introduced their very own FRP framework, making it possible to utilize the paradigm natively with declarative Swift API. The two frameworks share quite a few similarities in terms of principles and usage, so it can be not too daunting to get your feet wet with Combine if you have already been using RxSwift in your projects.</p>
<p>If you search around the topic, it‚Äôs easy to find a <a href="https://medium.com/gett-engineering/rxswift-to-apples-combine-cheat-sheet-e9ce32b14c5b">cheatsheet</a> for migrating from RxSwift to Combine summed up by <a href="https://twitter.com/freak4pc">Shai Mishali</a> which is helpful to have a good overview comparision between the two frameworks. In this article I would like to highlight some interesting points about Combine from the viewpoint of a developer who has been working with RxSwift for more than two years.</p>
<h2 id="publishers--subscribers">Publishers &amp; Subscribers</h2>
<p>These two are the equivalents of Observables and Observers in RxSwift. Together they make up the core components of Combine. As Apple put it:</p>
<blockquote>
<p>Combine declares publishers to expose values that can change over time, and subscribers to receive those values from the publishers.</p>
</blockquote>
<p>The great thing about using the native FRP framework is that it has been integrated into other Apple‚Äôs frameworks, making the migration process easier. Foundation framework has supported the use of Combine in some of its APIs, like <code>URLSession</code> in the following example:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">RepoListViewModel</span> {
    <span style="color:#66d9ef">var</span> cancellable: AnyCancellable?
    
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fetchRepos</span>() {
        <span style="color:#66d9ef">let</span> url = URL(string: <span style="color:#e6db74">&#34;https://api.github.com/users/itsmeichigo/repos&#34;</span>)<span style="color:#f92672">!</span>
        cancellable = URLSession.shared.dataTaskPublisher(<span style="color:#66d9ef">for</span>: url)
            .sink (receiveCompletion: { completion <span style="color:#66d9ef">in</span>
                <span style="color:#66d9ef">switch</span> completion {
                <span style="color:#66d9ef">case</span> .finished:
                    print(<span style="color:#e6db74">&#34;Get repos finished&#34;</span>)
                <span style="color:#66d9ef">case</span> <span style="color:#66d9ef">let</span> .failure(error):
                    print(<span style="color:#e6db74">&#34;Get repos failed: </span><span style="color:#e6db74">\(</span>error<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
                }
            }, receiveValue: { (data, response) <span style="color:#66d9ef">in</span>
                print(<span style="color:#e6db74">&#34;Got repos data: </span><span style="color:#e6db74">\(</span>data<span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
            })
    }
}
</code></pre></div><p>In this example, <code>URLSession</code> uses <code>Publisher</code> as a wrapper to emit signals to its subscribers on receipt of response from the URL request.¬†<code>.sink</code> is a method to create a subscription by connecting a subscriber of type <code>Sink</code> to a publisher. This method accepts one closure for execution when receiving new elements and another for handling completion. This is similar to RxSwift Observable&rsquo;s <code>subscribe</code> method which lets us handle when a stream emits new event, completes or errors out.</p>
<p>Subscriptions in Combine can also be handled by assigning values to class properties that are marked with <code>@Published</code> - which is quite similar to <code>bind(to:)</code> method in RxSwift Observable:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Repo</span>: Decodable {
    <span style="color:#66d9ef">let</span> name: String
    <span style="color:#66d9ef">let</span> description: String?
    <span style="color:#66d9ef">let</span> language: String?
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">RepoDetailViewModel</span> {
    @Published <span style="color:#66d9ef">var</span> repoDetail: Repo?
        
    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fetchRepoDetail</span>() {
        <span style="color:#66d9ef">let</span> url = URL(string: <span style="color:#e6db74">&#34;https://api.github.com/repos/itsmeichigo/Playgrounds&#34;</span>)<span style="color:#f92672">!</span>
        URLSession.shared.dataTaskPublisher(<span style="color:#66d9ef">for</span>: url)
            .tryMap(<span style="color:#960050;background-color:#1e0010">\</span>.data)
            .decode(type: Repo?.<span style="color:#66d9ef">self</span>, decoder: JSONDecoder())
            .replaceError(with: <span style="color:#66d9ef">nil</span>)
            .assign(to: <span style="color:#f92672">&amp;</span><span style="color:#960050;background-color:#1e0010">$</span>repoDetail)
    }
}
</code></pre></div><p>Note: In case you‚Äôre wondering, since parameter sent to this <code>assign</code> method is <code>inout</code>, an <code>&amp;</code> operator is required to precede <code>$repoDetail</code>. The <code>$</code> operator is used for accessing the wrapped property itself.</p>
<p>The preceding example uses the property wrapper <code>@Published</code> to create a publisher that outputs values of type <code>Repo?</code> and has failure type <code>Never</code> (meaning the stream never fails - more on that later). The <code>repoDetail</code> therefore can be observed for changes by another subscriber:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">RepoDetailViewController</span>: UIViewController {
    <span style="color:#66d9ef">@IBOutlet</span> <span style="color:#66d9ef">var</span> titleLabel: UILabel!
    <span style="color:#66d9ef">var</span> viewModel: RepoDetailViewModel!
    <span style="color:#66d9ef">var</span> cancellable: AnyCancellable?
    
    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">viewDidLoad</span>() {
        <span style="color:#66d9ef">super</span>.viewDidLoad()
        cancellable = viewModel.<span style="color:#960050;background-color:#1e0010">$</span>repoDetail
            .map { $0?.name }
            .assign(to: <span style="color:#960050;background-color:#1e0010">\</span>.text, on: titleLabel)

		viewModel.fetchRepoDetails()
    }
}
</code></pre></div><p>As can be noticed from the subscription of <code>repoDetail</code>, another method <code>assign(to:on:)</code> is used to assign the mapped <code>name</code> value to <code>titleLabel</code>&rsquo;s displayed text using KVO. This method keeps strong reference to the object passed to <code>on:</code>, so it should be used with caution to avoid retain cycle if you happen to send <code>self</code>. Although a quick workaround would be to send <code>weak self</code> instead, if you find yourself in such situation, it&rsquo;s time to use an <code>@Published</code> property instead (unfortunately <code>assign(to:)</code> is only available since iOS 14).</p>
<h2 id="subjects">Subjects</h2>
<p>Similar to RxSwift, Combine has the same concept of Subjects‚Ää‚Äî‚Ääthe types of publishers that allow injection of values to be published. Subjects are useful for quickly creating custom publishers and migrating from imperative programming to FRP. There are two built-in subjects:</p>
<ul>
<li><code>PassthroughSubject</code>: equivalent to PublishSubject in RxSwift. This subject broadcasts elements to downstream subscribers, suitable for stateless streams of events. This is usually used for observing user interactions (button taps, toggle switches etc.) or sending notifications.</li>
<li><code>CurrentValueSubject</code>: equivalent to BehaviorSubject in RxSwift. This subject wraps a stream of output of value type and exposes the most recently published element via <code>value</code> variable. New values can be injected to the stream by updating the <code>value</code> variable or using <code>send(_:)</code> method.</li>
</ul>
<h2 id="memory-management">Memory management</h2>
<p>If you look closely at the code examples in the first section, you‚Äôll notice the retaining of <code>AnyCancellable</code> after creating subscriptions. Methods¬†<code>.sink</code> and¬†<code>.assign(to:on:)</code> both return <code>AnyCancellable</code>, indicating that the subscriptions can be cancelled from outside. This retaining is important to keep the created data streams alive; and also to dispose them when they are no longer relevant - much like how <code>DisposeBag</code> is used in RxSwift.</p>
<p>Usually you would want to create more than one subscriptions in a class, so it is more practical to have a set of <code>AnyCancellable</code> objects to keep all the subscriptions in one place:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">RepoDetailViewController</span>: UIViewController {
    <span style="color:#66d9ef">@IBOutlet</span> <span style="color:#66d9ef">var</span> titleLabel: UILabel!
    <span style="color:#66d9ef">@IBOutlet</span> <span style="color:#66d9ef">var</span> descriptionLabel: UILabel!
    <span style="color:#66d9ef">var</span> viewModel: RepoDetailViewModel!
    <span style="color:#66d9ef">var</span> cancellables: Set&lt;AnyCancellable&gt; = []
    
    <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">viewDidLoad</span>() {
        <span style="color:#66d9ef">super</span>.viewDidLoad()
        viewModel.<span style="color:#960050;background-color:#1e0010">$</span>repoDetail
            .map { $0?.name }
            .assign(to: <span style="color:#960050;background-color:#1e0010">\</span>.text, on: titleLabel)
            .store(<span style="color:#66d9ef">in</span>: &amp;cancellables)
        
        viewModel.<span style="color:#960050;background-color:#1e0010">$</span>repoDetail
            .map { $0?.description }
            .assign(to: <span style="color:#960050;background-color:#1e0010">\</span>.text, on: descriptionLabel)
            .store(<span style="color:#66d9ef">in</span>: &amp;cancellables)

		viewModel.fetchRepoDetails()
    }
}
</code></pre></div><p>Here the lifecycle of <code>cancellablles</code> is tied with <code>RepoDetailViewController</code>, so when the view controller is released, the subscriptions stored in this property will all be cancelled and disposed as well.</p>
<p>But how about the method <code>assign(to:)</code>? Why didn&rsquo;t I retain the subscription made with it like I did with the other two methods?</p>

    <img src="https://media.giphy.com/media/UDFMOnaOrLx28/giphy.gif"  alt="https://media.giphy.com/media/UDFMOnaOrLx28/giphy.gif"  class="center"  />


<p>As you may have guessed, this method links the created subscription with the <code>@Published</code> property sent to it, so it does not require the same memory managment machanism as the two methods discussed earlier.</p>
<h2 id="type-matching-and-errorhandling">Type matching and error¬†handling</h2>
<p>In RxSwift, Observable is a generic type with an associated type Element defining the type of the data stream‚Äôs output. In Combine, a Publisher has two concerns: Output and Failure types. Failure type of a publisher can be either an <code>Error</code>-conforming type, or <code>Never</code> if it does not publish any error. So when creating a subscription, you have to make sure that the Input type of the subscriber match with the Output type of the publisher. More interestingly, their Failure types are also required to be the same, otherwise you&rsquo;ll encounter a mismatching types error.</p>
<p>Publisher extension has several operators to handle errors. In the <code>fetchRepoDetail()</code> example above I used <code>replaceError(with:)</code> to silent any decoding or response errors with <code>nil</code> since I wanted the failure type of the upstream publisher to match with that of the <code>@Published</code> property, which is <code>Never</code>. In cases when you are certain that no error should be thrown, <code>assertNoFailure()</code> can be used to transform failure type to <code>Never</code> or call assert otherwise. You can also use <code>retry()</code> to attempt recreating failed subscriptions to a specified number of times; or map the error to another publisher using <code>catch()</code>.</p>
<p>In real life situations, however, error handling is more often necessary‚Ää‚Äî‚Äähere‚Äôs how the code can be refactored for that purpose:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">RepoError</span>: Error {
    <span style="color:#66d9ef">case</span> url(URLError)
    <span style="color:#66d9ef">case</span> decode
    <span style="color:#66d9ef">case</span> unknown
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">RepoDetailViewModel</span> {
    <span style="color:#66d9ef">let</span> repoDetailSubject = CurrentValueSubject&lt;Repo?, RepoError&gt;(<span style="color:#66d9ef">nil</span>)
    
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">var</span> cancellable: Cancellable?
    
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fetchRepoDetails</span>() {
        <span style="color:#66d9ef">let</span> url = URL(string: <span style="color:#e6db74">&#34;https://api.github.com/repos/itsmeichigo/Playgrounds&#34;</span>)<span style="color:#f92672">!</span>
        cancellable = URLSession.shared.dataTaskPublisher(<span style="color:#66d9ef">for</span>: url)
            .tryMap(<span style="color:#960050;background-color:#1e0010">\</span>.data)
            .decode(type: Repo?.<span style="color:#66d9ef">self</span>, decoder: JSONDecoder())
            .mapError { error -&gt; RepoError <span style="color:#66d9ef">in</span>
                <span style="color:#66d9ef">switch</span> error {
                <span style="color:#66d9ef">case</span> <span style="color:#66d9ef">is</span> URLError:
                    <span style="color:#66d9ef">return</span> .url(error <span style="color:#66d9ef">as</span>! URLError)
                <span style="color:#66d9ef">case</span> <span style="color:#66d9ef">is</span> DecodingError:
                    <span style="color:#66d9ef">return</span> .decode
                <span style="color:#66d9ef">default</span>:
                    <span style="color:#66d9ef">return</span> .unknown
                }
            }
            .sink { [<span style="color:#66d9ef">weak</span> <span style="color:#66d9ef">self</span>] completion <span style="color:#66d9ef">in</span>
                <span style="color:#66d9ef">self</span>?.repoDetailSubject.send(completion: completion)
            } receiveValue: { [<span style="color:#66d9ef">weak</span> <span style="color:#66d9ef">self</span>] repos <span style="color:#66d9ef">in</span>
                <span style="color:#66d9ef">self</span>?.repoDetailSubject.send(repos)
            }
    }
}
</code></pre></div><p>In the above solution, I‚Äôve changed the <code>@Published</code> property to a <code>CurrentValueSubject</code> to change the error type from <code>Never</code> to <code>RepoError</code>. Then I used <code>mapError</code> function to transform the errors from upstream to my custom error type <code>RepoError</code>.  The result publisher was finally subscribed using a <code>Sink</code> to send values and completion event to the subject. It&rsquo;s a pity that we cannot use <code>assign(to:)</code> with a subject like how we can bind observables to subjects or observers in RxSwift - but we can further improve this piece of code in the next section.</p>
<h2 id="type-eraser">Type eraser</h2>
<p>A quick look at the <a href="https://developer.apple.com/documentation/combine/publisher">Apple documentation of Publisher</a> can show that most operators used on publishers return their respective types extending the <code>Publishers</code> enum. Take the code snippet from the previous section as an example, if you paste it in a Playground and open Quick Help panel to investigate the returned types of each operator, you&rsquo;ll be surprised how the types can get more and more complicated after each operator:</p>
<ul>
<li><code>URLSession.shared.dataTaskPublisher</code> returns publisher of type <code>DataTaskPublisher</code></li>
<li>applying <code>tryMap</code>, we get the result of type <code>Publishers.TryMap&lt;URLSession.DataTaskPublisher, T&gt;</code></li>
<li>moving on with <code>decode</code>, we get <code>Publishers.Decode&lt;Publishers.TryMap&lt;URLSession.DataTaskPublisher, Data&gt;, Item, Coder&gt; where Item¬†: Decodable, Coder¬†: TopLevelDecoder, Self.Output == Coder.Input</code></li>
<li>finally, with <code>mapError</code> we end up with <code>Publishers.MapError&lt;Publishers.Decode&lt;Publishers.TryMap&lt;URLSession.DataTaskPublisher, Data&gt;, Repo?, JSONDecoder&gt;, E&gt;</code></li>
</ul>
<p>If we want to expose the publisher to external subscribers, we‚Äôll need a more generic type - <code>AnyPublisher</code> - as the subscribers only concern about the output and failure types of the publisher they subscribe to. This is where type erasing comes to play, and Combine has a method for this: <code>eraseToAnyPublisher()</code>. Let&rsquo;s see how we can use this to improve the implementation in the previous section:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fetchDetail</span>() -&gt; AnyPublisher&lt;Repo, RepoError&gt; {
    <span style="color:#66d9ef">let</span> url = URL(string: <span style="color:#e6db74">&#34;https://api.github.com/repos/itsmeichigo/Playgrounds&#34;</span>)<span style="color:#f92672">!</span>
    <span style="color:#66d9ef">return</span> URLSession.shared.dataTaskPublisher(<span style="color:#66d9ef">for</span>: url)
        .tryMap(<span style="color:#960050;background-color:#1e0010">\</span>.data)
        .decode(type: Repo.<span style="color:#66d9ef">self</span>, decoder: JSONDecoder())
        .mapError { error -&gt; RepoError <span style="color:#66d9ef">in</span>
            <span style="color:#66d9ef">switch</span> error {
            <span style="color:#66d9ef">case</span> <span style="color:#66d9ef">is</span> URLError:
                <span style="color:#66d9ef">return</span> .url(error <span style="color:#66d9ef">as</span>! URLError)
            <span style="color:#66d9ef">case</span> <span style="color:#66d9ef">is</span> DecodingError:
                <span style="color:#66d9ef">return</span> .decode
            <span style="color:#66d9ef">default</span>:
                <span style="color:#66d9ef">return</span> .unknown
            }
        }
        .eraseToAnyPublisher()
}
</code></pre></div><p>This time, a publisher is returned immediately from <code>fetchDetail()</code> function, and the <code>RepoDetailViewController</code> can subscribe directly to it and handle any received events. I can then safely remove redundant use and subscription of <code>CurrentValueSubject</code>, and the code looks much neater. The returned publisher is of type <code>AnyPublisher&lt;Repo?, RepoError&gt;</code>, which is informative enough for any external subscribers.</p>
<h2 id="future-anddeferred">Future and¬†Deferred</h2>
<p>In Combine, many publishers invoke their closures and emit values only after they get a subscription. For instance, a <code>DataTaskPublisher</code> starts a url request and emit subsequent result whenever it receives demand request from a subscriber. This also means that several subscriptions made to the same publisher can trigger multiple url requests and receive different response - which is not desirable if we just want to observe the same stream. Applying <code>share()</code> operator can solve that problem, making sure that the same output of the publisher is shared among its subscribers.</p>
<p>An alternative would be to wrap the <code>URLSessionDataTask</code> creation in a <code>Future</code>. It&rsquo;s a type of publisher that completes after emitting a <strong>single</strong> output value or failure. This result is republished to any subscriber listens to the same <code>Future</code> object. It&rsquo;s suitable for wrapping any asynchronous work that expects only one result. Since a url requests always returns response once and then completes - this is a perfect case for the use of <code>Future</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">fetchDetail</span>() -&gt; Future&lt;Repo, RepoError&gt; {
    <span style="color:#66d9ef">let</span> url = URL(string: <span style="color:#e6db74">&#34;https://api.github.com/repos/itsmeichigo/Playgrounds&#34;</span>)<span style="color:#f92672">!</span>
    <span style="color:#66d9ef">return</span> Future { promise <span style="color:#66d9ef">in</span>
        URLSession.shared.dataTask(with: url) { (data, response, error) <span style="color:#66d9ef">in</span>
            <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> error = error <span style="color:#66d9ef">as</span>? URLError {
                promise(.failure(.url(error)))
            } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> data = data {
                <span style="color:#66d9ef">do</span> {
                    <span style="color:#66d9ef">let</span> decoder = JSONDecoder()
                    <span style="color:#66d9ef">let</span> detail = <span style="color:#66d9ef">try</span> decoder.decode(Repo.<span style="color:#66d9ef">self</span>, from: data)
                    promise(.success(detail))
                } <span style="color:#66d9ef">catch</span> {
                    promise(.failure(.decode))
                }
            } <span style="color:#66d9ef">else</span> {
                promise(.failure(.unknown))
            }
        }.resume()
    }
}
</code></pre></div><p>Using <code>Future</code> requires extra caution though, especially if you apply <code>eraseToAnyPublisher()</code> as developers on the receiving end may not be aware of its distinctive features:</p>
<ul>
<li><code>Future</code> immediately invokes the asynchronous request in its closure at the time of creation.</li>
<li><code>Future</code> emits result only once so even though it&rsquo;s still possible to call <code>retry()</code> on it, the operator can&rsquo;t create new subscription after the publisher completes.</li>
</ul>
<p>A solution to delay the start of a <code>Future</code>&rsquo;s work while still taking advantage of its one-time result is to wrap it inside a <code>Deferred</code>. This is another special kind of publisher whose job is to wait for a subscription before triggering the supplied closure to create a new publisher. The implementation is simple:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-swift" data-lang="swift"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">createDeferred</span>() -&gt; Deferred&lt;Future&lt;Repo, RepoError&gt;<span style="color:#f92672">&gt;</span> {
    Deferred {
        Future { promise <span style="color:#66d9ef">in</span>
            <span style="color:#75715e">// The rest of implementation</span>
        }
    }
}
</code></pre></div><p>With the use of <code>Deferred</code>, a new <code>Future</code> object is created every time there&rsquo;s a new subscription, making the <code>Future</code> lazy - which is more similar to <code>Single</code> in RxSwift.</p>
<h2 id="backpressure">Backpressure</h2>
<p>I cannot end this article without mentioning backpressure. It defines the core principle of Combine: In a subscription, the subscriber controls the handling of events from the upstream publisher, including number of values to be received. As per the documentation on Publisher protocol, the following methods of the subscriber will be triggerred when it listens to a publisher:</p>
<ul>
<li><code>receive(subscription:)</code>: Notifies the subscriber of a succesful subscribe request and returns a <code>Subscription</code> instance. The subscriber uses this subscription object to request a <code>Subscriber.Demands</code> specifying the number items to receive, if any.</li>
<li><code>receive(_:)</code>: Delivers one element from the publisher to the subscriber. This methods returns another <code>Subscriber.Demands</code> to let the publisher know if any more demand for is needed.</li>
<li><code>receive(completion:)</code>: Informs the subscriber that publishing has ended, either normally or with an error.</li>
</ul>
<p>The specification of demands makes sure that the subscription sends just enough items as requested by the subscriber and no more. Below is an illustration for a <code>Sink</code> subscriber to visualize the relationship and clarify the explanations a little further (apologies for my poor drawing skills üôÇ):</p>
<p><img src="combine-carbon.png" alt="Illustration"></p>
<p>Backpressure is an advanced topic and as Apple keeps their implementations of publishers and subscribers private, the complexity of this management is hidden from developers. Understanding the principle of backpressure makes customization for publishers and subscribers possible. One particular use case for this is <a href="https://github.com/CombineCommunity/CombineCocoa">CombineCocoa by CombineCommunity</a>, which makes integration of Combine when using UIControls much more convenient. However, Apple strongly encourages that developers use the built-in convenience publishers and subjects instead of implementing custom ones, so it is important to look for simple solutions before tempting to overengineer to avoid bringing complexity and potential bugs to your projects.</p>
<h2 id="epilogue">Epilogue</h2>
<p>Since Combine only supports iOS 13 onwards, it may be a bit early for most of current projects to adopt. Nevertheless, it‚Äôs never too soon to learn new tech and start experimenting with it to get yourself comfortable and ‚Äúrelevant‚Äù. The framework itself is still under development and improvement, so don‚Äôt forget to check back in future WWDCs for any cool new updates. I hope this article inspires you to dive deeper and learn more about Combine. I would like to give my thanks to <a href="https://twitter.com/DonnyWals">Donny Wals</a> for his book <a href="https://gumroad.com/donnywals#XVbKP">Practical Combine</a>, as well as all the resources listed in the References section for making this article possible. In the meantime, you can also check out <a href="https://github.com/CombineCommunity/RxCombine">RxCombine</a> to discover the possiblities of bridging between the two frameworks. Have fun!</p>
<h2 id="references">References</h2>
<p><a href="https://developer.apple.com/documentation/combine">Apple Developer Documentation</a></p>
<p><a href="https://www.avanderlee.com/swift/combine/">Getting started with the Combine framework in Swift - SwiftLee</a></p>
<p><a href="https://github.com/CombineCommunity/rxswift-to-combine-cheatsheet">CombineCommunity/rxswift-to-combine-cheatsheet</a></p>
<p><a href="https://heckj.github.io/swiftui-notes/">Using Combine</a></p>
<p><a href="https://www.apeth.com/UnderstandingCombine/">Understanding Combine</a></p>
]]></content></item><item><title>Learning SwiftUI by Building a Slack-like Emoji Picker</title><link>/posts/swiftui-happy-panel/</link><pubDate>Wed, 02 Sep 2020 21:23:02 +0701</pubDate><guid>/posts/swiftui-happy-panel/</guid><description>I started learning SwiftUI around August 2020 first with Apple&amp;rsquo;s SwiftUI Tutorials. The tutorials were really fun and got me excited with using SwiftUI. I then continued with Paul Hudson&amp;rsquo;s series 100 Days of SwiftUI. Around the end of series, I could not hesitate any longer so I started a new Xcode project and build one of the things I like most about Slack app: the emoji picker!
The point of the Happy Panel project was to learn SwiftUI and make use of its declarative syntax to build a complicated control with gestures and animations in a few lines of code.</description><content type="html"><![CDATA[<p>I started learning SwiftUI around August 2020 first with <a href="https://developer.apple.com/tutorials/SwiftUI">Apple&rsquo;s SwiftUI Tutorials</a>. The tutorials were really fun and got me excited with using SwiftUI. I then continued with Paul Hudson&rsquo;s series <a href="https://www.hackingwithswift.com/100/swiftui">100 Days of SwiftUI</a>. Around the end of series, I could not hesitate any longer so I started a new Xcode project and build one of the things I like most about Slack app: the emoji picker!</p>
<p><img src="https://github.com/itsmeichigo/HappyPanel/blob/master/screenshot.png?raw=true" alt="Happy Panel"></p>
<p>The point of the <a href="https://github.com/itsmeichigo/HappyPanel">Happy Panel project</a> was to learn SwiftUI and make use of its declarative syntax to build a complicated control with gestures and animations in a few lines of code. Because the biggest motivation for me to learn something new is to be able to make something beautiful and performant.</p>
<p>Below is how I tried to solve the problem - more like a note on what I learned.</p>
<h1 id="starting-out-with-the-smallest-components-first">Starting out with the smallest components first</h1>
<ul>
<li>Search bar: essentially a text field with grey background color and search icon on the left. Search button should show up when the field is focused and disappear otherwise.</li>
<li>Emoji grid: a grid of buttons that returns the content to its parent when tapped. The grid can be built with a combination of VStack and HStack (which requires a 2-dimensional array), but SwiftUI 2 provides grid which is super helpful so I used LazyVGrid instead. This is a toy project, I don&rsquo;t care about users using iOS 13 anyway.</li>
<li>List with section headers containing the emoji grid. The cool thing about SwiftUI is that a lot of UI components are supported natively without much needed code and here&rsquo;s one of them: a <code>List</code> wrapping around a <code>Section</code> with header will give you a table view with sticky headers. This is way too convenient comparing to how I&rsquo;d have had to implement the same thing with UIKit.</li>
<li>Search result rows for filtered emojis.</li>
<li>Search result list.</li>
<li>Main content view: containing all the above components.</li>
<li>Section title picker to navigate between sections. I want this to float above the main content view so it&rsquo;s not contained in the main content view.</li>
<li>Main panel: containing a dimmed background, the main content view and the section title picker.</li>
</ul>
<h1 id="navigating-between-sections">Navigating between sections</h1>
<p>With the help of <code>ScrollViewReader</code> and <code>ScrollViewProxy</code>, navigating to a desired section of a list is so easy with a simple <code>scrollTo(_ id:)</code> function. The problem is I had to learn how to use it the hard way with very much frustration involved.</p>
<p>The magic of <code>ScrollViewProxy</code> is that it scans through the children to find the view with the <code>id</code> that you send it. It&rsquo;s as simple as that, but at first I tried to call the scroll function on the <code>List</code>, which crashes the app since my <code>List</code> doesn&rsquo;t immediately contain the view that I was looking for, but has it embeded inside a child <code>ForEach</code>. Moving the call downward to the child was the solution that took me almost a whole day.</p>
<p>There&rsquo;s a feature that I have yet to implement. It is expected that when the emoji grid is scrolled the section picker updates its selected segment accordingly. As far as I know this is natively impossible since SwiftUI <code>List</code> doesn&rsquo;t offer a way to read the current offset but if it does some day, I think I can compare the offset with the pre-calculated frame of each section. This is still fugly, and also when I can determine the current visible section and update the <code>currentCategory</code> environment variable, it would cause a circular reference since the picker itself is listening on any change of this variable to scroll to the correct section. So is there a better solution?</p>
<h1 id="moving-the-main-panel-with-drag-gesture">Moving the main panel with drag gesture</h1>
<p>Updating the main panel offset with drag gesture isn&rsquo;t the hardest part to begin with. I keep the 2 variables - one for the calculated offset and one for the last offset when the dragging gesture ends, which is used for calculated the first variable. Then I have some magic code to magnetize the panel to the top or close the panel based on where the gesture ends.</p>
<p>A problem I noticed was that if I move the main content view&rsquo;s code to main panel, the dragging performance suffers. I keep the same code and move it to a separate file, the dragging gets as smooth as it can ever get. This remains a mystery to me.</p>
<p>There&rsquo;s a challenge here though. Slack utilizes the drag gesture on the emoji grid view very well, when the panel is in half mode you can&rsquo;t scroll the grid but instead can only drag the panel. I tried to mimick this behavior but there&rsquo;s no native way to do intervene the scrolling behavior of the <code>List</code>. So I just leave it there and wait to see when SwiftUI provides such feature, if ever.</p>
<h1 id="environmentobject">@EnvironmentObject</h1>
<p>Originally I used a lot of <code>@State</code> and <code>@Binding</code> to send some states back and forth between children and parent views. I then decided to clean the mess up by using <code>@EnvironmentObject</code> so that all children and parents can have access to the same states of the view. This causes me to think if this is the intended behavior of the property wrapper itself - if it makes the state globablly available to all the listeners to both read and write, would it be safe? Like I may have some code in a view that has nothing to do with search keyword but alter the variable and the control will break. If SwiftUI&rsquo;s main purpose is to maintain states in a clean way then my usage of @EnvironmentObject is totally against the rule.</p>
<h1 id="an-open-ending-updated-in-july-2021">An open ending (updated in July 2021)</h1>
<p>I left the project with an open ending due to several challenges:</p>
<p>I have yet to handle <code>List</code> to behave properly to pan gesture. You can see some performance hitch when dragging the panel back and forth. In WWDC21 Apple introduced <a href="https://developer.apple.com/documentation/uikit/uisheetpresentationcontroller">UISheetPresentationController</a> - however this is not available natively on SwiftUI. It is possible to use wrapper though, as per <a href="https://www.donnywals.com/using-uisheetpresentationcontroller-in-swiftui/">Donny Wal&rsquo;s article</a>. I will need to look at that and see how I can improve the panel for iOS 15+.</p>
<p>As mentioned earlier, section picker needs to be updated when scrolling to respective sections. I have found a solution for this in a Mac app (more on that right below) - but the solution is not feasible on the floating panel due to the complication of gesture recognizers.</p>
<p>On a flip side, I started a menu bar app on MacOS and it was actually really fun since Mac app development is all new to me. I will note my learning on a separate post, so please stay tuned!</p>
<p>Until next time! üëã</p>
]]></content></item></channel></rss>